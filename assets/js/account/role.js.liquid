angular.module('storefront.account')
.factory('roleService', ['$q', '$http', 'storefront.accountsApi', 'storefront.rolesApi', function ($q, $http, accountsApi, rolesApi) {
    var service = {
        available: null,
        get: null,
        set: null
    };

    // get all available roles from settings
    service._roles = {{ settings.available_roles | json }};
    rolesApi.search(function (rolesSearch) {
        service.available = _.map(service._roles, function(role) {
            var realRole = _.findWhere(rolesSearch.roles, { name: role });
            return angular.extend({}, realRole, { description: 'customer.roles.descriptions.' + role.toLowerCase().replace(" ", "_") });
        });
    });

    service.get = function(member){
        var availableRoles = angular.copy(service.available);
        _.each(availableRoles, function(availableRole) {            
            // role is assigned to member if any of member's security accounts has this role assigned
            var roles = _.chain(member.securityAccounts).map(function(account) { return account.roles; }).flatten().value();
            availableRole.assigned = _.some(roles,
            function(assignedRole) {
                return availableRole.name === assignedRole.name;
            });
        });
        // if multiple roles assigned, return the role with minimal privilidges
        return _.last(_.where(availableRoles, { assigned: true }));
    };

    service.set = function(member, role) {
        // assign current role to all member's security accounts
        return $q.all(_.map(member.securityAccounts, function(account) {
            account.roles = _.without.apply(_, [account.roles].concat(_.filter(account.roles, function(role) { return _.contains(service._roles, role.name); })));
            account.roles.push(role);
            return accountsApi.update(account).$promise;
        }));
    };

    return service;
}]);